<!DOCTYPE html>
<html lang="ro">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>BYBIT HEATMAP | Guap üí∞</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;500;700;900&family=Rajdhani:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
        :root { 
            --neon-green: #00ff41; --neon-green-glow: rgba(0, 255, 65, 0.4);
            --neon-red: #ff0040; --neon-red-glow: rgba(255, 0, 64, 0.4);
            --accent-gold: #ffd700; --bg-dark: #050508;
        }
        html, body { font-family: 'Rajdhani', sans-serif; background: var(--bg-dark); min-height: 100vh; color: #fff; overflow-x: hidden; }
        body::before {
            content: ''; position: fixed; top: 0; left: 0; right: 0; bottom: 0;
            background: linear-gradient(90deg, rgba(0, 255, 65, 0.03) 1px, transparent 1px), linear-gradient(rgba(0, 255, 65, 0.03) 1px, transparent 1px), repeating-linear-gradient(0deg, transparent, transparent 3px, rgba(255, 0, 64, 0.02) 3px, rgba(255, 0, 64, 0.02) 6px), radial-gradient(ellipse at 20% 30%, rgba(0, 255, 65, 0.05) 0%, transparent 50%), radial-gradient(ellipse at 80% 70%, rgba(255, 0, 64, 0.05) 0%, transparent 50%), var(--bg-dark);
            background-size: 60px 60px, 60px 60px, 100% 100%, 100% 100%, 100% 100%, 100% 100%;
            z-index: -2;
        }
        #particles-canvas { position: fixed; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: -1; }
        .scan-line { position: fixed; top: 0; left: 0; right: 0; height: 4px; background: linear-gradient(90deg, transparent, var(--neon-green), transparent); opacity: 0.3; animation: scanDown 6s linear infinite; pointer-events: none; z-index: 1000; }
        @keyframes scanDown { 0% { top: -4px; } 100% { top: 100vh; } }
        .header { position: fixed; top: 0; left: 0; right: 0; padding: 12px 16px; background: linear-gradient(180deg, rgba(10,10,15,0.98), rgba(10,10,15,0.8) 60%, transparent); z-index: 100; display: flex; justify-content: space-between; align-items: center; backdrop-filter: blur(10px); border-bottom: 1px solid rgba(0, 255, 65, 0.1); box-shadow: 0 2px 20px rgba(0, 255, 65, 0.1); }
        .logo { font-family: 'Orbitron', sans-serif; font-size: 1.1rem; font-weight: 700; letter-spacing: 3px; background: linear-gradient(135deg, #fff, var(--accent-gold), #fff); background-size: 200% 200%; -webkit-background-clip: text; -webkit-text-fill-color: transparent; animation: shimmer 3s ease-in-out infinite; }
        @keyframes shimmer { 0%, 100% { background-position: 0% 50%; } 50% { background-position: 100% 50%; } }
        .header-controls { display: flex; gap: 8px; align-items: center; }
        .filter-btn { background: rgba(0, 255, 65, 0.1); border: 1px solid rgba(0, 255, 65, 0.3); color: var(--neon-green); padding: 6px 12px; border-radius: 20px; font-family: 'Rajdhani', sans-serif; font-size: 0.75rem; font-weight: 600; cursor: pointer; transition: all 0.3s ease; text-transform: uppercase; letter-spacing: 1px; }
        .filter-btn:hover, .filter-btn.active { background: rgba(0, 255, 65, 0.25); box-shadow: 0 0 15px rgba(0, 255, 65, 0.3); }
        .last-update { font-size: 0.75rem; color: rgba(255,255,255,0.5); display: flex; align-items: center; gap: 6px; }
        .update-dot { width: 8px; height: 8px; background: var(--neon-green); border-radius: 50%; animation: pulse 1.5s ease-in-out infinite; box-shadow: 0 0 10px var(--neon-green); }
        .ws-status { width: 8px; height: 8px; border-radius: 50%; background: #666; transition: all 0.3s; }
        .ws-status.connected { background: var(--neon-green); box-shadow: 0 0 10px var(--neon-green); animation: pulse 1s ease-in-out infinite; }
        @keyframes pulse { 0%, 100% { opacity: 1; transform: scale(1); } 50% { opacity: 0.6; transform: scale(1.1); } }
        .container { padding-top: 70px; min-height: 100vh; }
        #bubble-container { width: 100%; min-height: calc(100vh - 70px); position: relative; }
        .bubble-group { cursor: pointer; transition: transform 0.3s ease; }
        .bubble-group:hover { transform: scale(1.1); }
        .bubble-spiral { filter: drop-shadow(0 0 12px currentColor); }
        .spiral-path { fill: none; stroke-width: 3; stroke-linecap: round; }
        .bubble-label { font-family: 'Orbitron', sans-serif; font-weight: 700; text-anchor: middle; pointer-events: none; fill: #fff; text-shadow: 0 0 10px rgba(0,0,0,0.9); }
        .bubble-change { font-family: 'Rajdhani', sans-serif; font-weight: 600; text-anchor: middle; pointer-events: none; fill: #fff; text-shadow: 0 0 8px rgba(0,0,0,0.9); }
        .loading { position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); text-align: center; z-index: 50; }
        .loading-spinner { width: 50px; height: 50px; border: 3px solid rgba(0,255,65,0.2); border-top-color: var(--neon-green); border-radius: 50%; animation: spin 1s linear infinite; margin: 0 auto 15px; }
        @keyframes spin { to { transform: rotate(360deg); } }
        .modal-overlay { position: fixed; inset: 0; background: rgba(5, 5, 8, 0.95); backdrop-filter: blur(20px); z-index: 1000; display: none; justify-content: center; align-items: flex-end; }
        .modal-overlay.active { display: flex; }
        .modal-content { background: linear-gradient(145deg, rgba(15,10,20,0.98), rgba(8,8,12,0.99)); border-radius: 24px 24px 0 0; padding: 24px 20px 40px; width: 100%; max-width: 500px; max-height: 80vh; border-top: 2px solid; border-image: linear-gradient(90deg, var(--neon-green), var(--neon-red)) 1; animation: slideUp 0.3s ease-out; overflow-y: auto; }
        @keyframes slideUp { from { transform: translateY(100%); opacity: 0; } to { transform: translateY(0); opacity: 1; } }
        .modal-handle { width: 40px; height: 4px; background: linear-gradient(90deg, rgba(0,255,65,0.5), rgba(255,0,64,0.5)); border-radius: 2px; margin: 0 auto 20px; }
        .coin-header { text-align: center; margin-bottom: 20px; }
        .coin-symbol { font-family: 'Orbitron', sans-serif; font-size: 2rem; font-weight: 900; letter-spacing: 3px; }
        .coin-change { font-family: 'Orbitron', sans-serif; font-size: 2.5rem; font-weight: 700; margin-top: 8px; }
        .coin-change.positive { color: var(--neon-green); text-shadow: 0 0 20px var(--neon-green-glow); }
        .coin-change.negative { color: var(--neon-red); text-shadow: 0 0 20px var(--neon-red-glow); }
        .chart-container { width: 100%; height: 180px; margin: 15px 0; background: rgba(255,255,255,0.02); border-radius: 12px; padding: 12px; }
        .stats-grid { display: grid; grid-template-columns: repeat(2, 1fr); gap: 12px; margin-top: 15px; }
        .stat-item { background: rgba(255,255,255,0.03); padding: 16px; border-radius: 12px; border: 1px solid rgba(255,255,255,0.08); }
        .stat-label { font-size: 0.7rem; color: rgba(255,255,255,0.4); text-transform: uppercase; letter-spacing: 2px; margin-bottom: 6px; }
        .stat-value { font-family: 'Orbitron', sans-serif; font-size: 1rem; font-weight: 600; color: #fff; }
        @media (max-width: 768px) { .header { padding: 10px 12px; } .logo { font-size: 0.9rem; } .filter-btn { padding: 4px 10px; font-size: 0.7rem; } .coin-symbol { font-size: 1.6rem; } .coin-change { font-size: 2rem; } .chart-container { height: 150px; } }
    </style>
</head>
<body>
    <div class="scan-line"></div>
    <canvas id="particles-canvas"></canvas>
    
    <div class="header">
        <div class="logo">üí∞ BYBIT</div>
        <div class="header-controls">
            <button class="filter-btn active" onclick="setSort('change')" id="btn-change">% CHANGE</button>
            <button class="filter-btn" onclick="setSort('volume')" id="btn-volume">VOLUME</button>
            <button class="filter-btn" onclick="setSort('alpha')" id="btn-alpha">A-Z</button>
        </div>
        <div class="last-update">
            <div class="ws-status" id="ws-status"></div>
            <span class="update-dot"></span>
            <span id="update-time">--:--</span>
        </div>
    </div>
    
    <div class="loading" id="loading">
        <div class="loading-spinner"></div>
        <div style="color: rgba(255,255,255,0.5); font-size: 0.9rem;">Loading market data...</div>
    </div>
    
    <div class="container" id="container" style="display: none;">
        <div id="bubble-container"></div>
    </div>
    
    <div class="modal-overlay" id="modal" onclick="closeModal(event)">
        <div class="modal-content" onclick="event.stopPropagation()">
            <div class="modal-handle"></div>
            <div class="coin-header">
                <div class="coin-symbol" id="modal-symbol">BTC</div>
                <div class="coin-change" id="modal-change">+5.23%</div>
            </div>
            <div class="chart-container">
                <canvas id="priceChart"></canvas>
            </div>
            <div class="stats-grid">
                <div class="stat-item"><div class="stat-label">Pre»õ</div><div class="stat-value" id="modal-price">-</div></div>
                <div class="stat-item"><div class="stat-label">Volum 24h</div><div class="stat-value" id="modal-volume">-</div></div>
                <div class="stat-item"><div class="stat-label">Max 24h</div><div class="stat-value" id="modal-high">-</div></div>
                <div class="stat-item"><div class="stat-label">Min 24h</div><div class="stat-value" id="modal-low">-</div></div>
            </div>
        </div>
    </div>

    <script>
        let bubbleData = [], isFirstLoad = true, currentSort = 'change';
        let ws = null, priceChart = null, currentModalCoin = null;
        
        // Particles
        const canvas = document.getElementById('particles-canvas');
        const ctx = canvas.getContext('2d');
        let particles = [];
        function resizeCanvas() { canvas.width = window.innerWidth; canvas.height = window.innerHeight; }
        resizeCanvas(); window.addEventListener('resize', resizeCanvas);
        class Particle { constructor() { this.reset(); } reset() { this.x = Math.random() * canvas.width; this.y = Math.random() * canvas.height; this.size = Math.random() * 2 + 0.5; this.speedX = (Math.random() - 0.5) * 0.5; this.speedY = (Math.random() - 0.5) * 0.5; this.color = Math.random() > 0.5 ? 'rgba(0, 255, 65, ' : 'rgba(255, 0, 64, '; this.alpha = Math.random() * 0.5 + 0.1; this.life = Math.random() * 100 + 50; } update() { this.x += this.speedX; this.y += this.speedY; this.life--; if (this.life <= 0 || this.x < 0 || this.x > canvas.width || this.y < 0 || this.y > canvas.height) this.reset(); } draw() { ctx.fillStyle = this.color + this.alpha + ')'; ctx.beginPath(); ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2); ctx.fill(); } }
        for (let i = 0; i < 50; i++) particles.push(new Particle());
        function animateParticles() { ctx.clearRect(0, 0, canvas.width, canvas.height); particles.forEach(p => { p.update(); p.draw(); }); requestAnimationFrame(animateParticles); }
        animateParticles();
        
        // WebSocket
        function connectWebSocket() {
            try {
                ws = new WebSocket('wss://stream.bybit.com/v5/public/linear');
                ws.onopen = () => { document.getElementById('ws-status').classList.add('connected'); ws.send(JSON.stringify({ op: 'subscribe', args: ['tickers.24h'] })); };
                ws.onmessage = (event) => { const data = JSON.parse(event.data); if (data.topic === 'tickers.24h' && data.data) updateFromWebSocket(data.data); };
                ws.onclose = () => { document.getElementById('ws-status').classList.remove('connected'); setTimeout(connectWebSocket, 5000); };
                ws.onerror = () => ws.close();
            } catch (e) { console.error('WS error:', e); }
        }
        
        function updateFromWebSocket(data) {
            let updated = false;
            data.forEach(ticker => {
                if (!ticker.symbol.endsWith('USDT')) return;
                const symbol = ticker.symbol.replace('USDT', '');
                const coin = bubbleData.find(c => c.symbol === symbol);
                if (coin) {
                    coin.change24h = parseFloat(ticker.price24hPcnt) * 100;
                    coin.price = parseFloat(ticker.lastPrice);
                    coin.volume24h = parseFloat(ticker.volume24h) * parseFloat(ticker.lastPrice);
                    updated = true;
                    if (currentModalCoin === symbol) updateModalData(coin);
                }
            });
            if (updated) { updateBubbles(); updateTime(); }
        }
        
        async function loadData() {
            if (isFirstLoad) document.getElementById('loading').style.display = 'block';
            try {
                const res = await fetch('https://api.bybit.com/v5/market/tickers?category=linear');
                const data = await res.json();
                if (data.retCode !== 0) throw new Error(data.retMsg);
                
                bubbleData = data.result.list
                    .filter(i => i.symbol.endsWith('USDT'))
                    .map(i => ({
                        symbol: i.symbol.replace('USDT', ''),
                        change24h: parseFloat(i.price24hPcnt) * 100,
                        price: parseFloat(i.lastPrice),
                        volume24h: parseFloat(i.volume24h) * parseFloat(i.lastPrice),
                        high24h: parseFloat(i.highPrice24h),
                        low24h: parseFloat(i.lowPrice24h)
                    }))
                    .filter(i => !isNaN(i.change24h));
                
                bubbleData.sort((a, b) => Math.abs(b.change24h) - Math.abs(a.change24h));
                
                if (isFirstLoad) {
                    document.getElementById('loading').style.display = 'none';
                    document.getElementById('container').style.display = 'block';
                    renderBubbles();
                    isFirstLoad = false;
                    connectWebSocket();
                } else {
                    updateBubbles();
                }
                updateTime();
            } catch (e) {
                console.error('Error:', e);
                document.getElementById('loading').innerHTML = `
                    <div style="color: #ff0040; text-align: center;">
                        <div>‚ö†Ô∏è Error loading data</div>
                        <button onclick="loadData()" style="margin-top: 15px; padding: 10px 20px; background: rgba(0,255,65,0.2); border: 1px solid #00ff41; color: #00ff41; border-radius: 20px; cursor: pointer;">Retry</button>
                    </div>`;
            }
        }
        
        function setSort(type) {
            currentSort = type;
            document.querySelectorAll('.filter-btn').forEach(btn => btn.classList.remove('active'));
            document.getElementById('btn-' + type).classList.add('active');
            if (type === 'change') bubbleData.sort((a, b) => Math.abs(b.change24h) - Math.abs(a.change24h));
            else if (type === 'volume') bubbleData.sort((a, b) => b.volume24h - a.volume24h);
            else if (type === 'alpha') bubbleData.sort((a, b) => a.symbol.localeCompare(b.symbol));
            renderBubbles();
        }
        
        function updateTime() { document.getElementById('update-time').textContent = new Date().toLocaleTimeString('ro-RO', { hour: '2-digit', minute: '2-digit', second: '2-digit' }); }
        
        function getColor(c) { return c >= 0 ? d3.interpolateRgb('#00ff41', '#39ff14')(Math.min(c / 20, 1)) : d3.interpolateRgb('#ff0040', '#ff1744')(Math.min(Math.abs(c) / 20, 1)); }
        
        // SIMPLE BUBBLE POSITIONING - NO FORCE SIMULATION
        function renderBubbles() {
            const container = document.getElementById('bubble-container');
            const w = window.innerWidth;
            const isM = w < 768;
            
            d3.select('#bubble-container').selectAll('*').remove();
            
            if (bubbleData.length === 0) return;
            
            const gainers = bubbleData.filter(d => d.change24h >= 0).slice(0, 20);
            const losers = bubbleData.filter(d => d.change24h < 0).slice(0, 20);
            
            // Calculate positions manually - no force simulation
            const baseRadius = isM ? 22 : 32;
            const colCount = isM ? 3 : 4;
            const spacingX = isM ? w / 3.5 : w / 5.5;
            const spacingY = isM ? 90 : 110;
            
            const gainersPos = gainers.map((d, i) => {
                const col = i % colCount;
                const row = Math.floor(i / colCount);
                const x = (isM ? 40 : 100) + col * spacingX + (Math.random() - 0.5) * 20;
                const y = 100 + row * spacingY + (Math.random() - 0.5) * 15;
                const r = baseRadius + Math.min(Math.abs(d.change24h) / 20, 1) * 12;
                return { ...d, x, y, r };
            });
            
            const losersPos = losers.map((d, i) => {
                const col = i % colCount;
                const row = Math.floor(i / colCount);
                const x = (isM ? w / 2 + 20 : w / 2 + 100) + col * spacingX + (Math.random() - 0.5) * 20;
                const y = 100 + row * spacingY + (Math.random() - 0.5) * 15;
                const r = baseRadius + Math.min(Math.abs(d.change24h) / 20, 1) * 12;
                return { ...d, x, y, r };
            });
            
            const all = [...gainersPos, ...losersPos];
            const h = Math.max(window.innerHeight - 70, (Math.ceil(20 / colCount) * spacingY) + 150);
            
            const svg = d3.select('#bubble-container').append('svg').attr('width', w).attr('height', h);
            
            const bubbles = svg.selectAll('.bubble-group').data(all).enter().append('g').attr('class', 'bubble-group').on('click', (e, d) => showModal(d));
            
            bubbles.each(function(d) {
                const g = d3.select(this);
                const col = getColor(d.change24h);
                const rad = d.r;
                
                // Outer glow
                g.append('circle').attr('r', rad + 12).attr('fill', d3.color(col).copy({opacity: 0.1}));
                
                // Main spiral group
                const sp = g.append('g').attr('class', 'bubble-spiral').style('color', col);
                
                // Draw spiral
                for (let turns = 2; turns >= 0.5; turns -= 0.5) {
                    let path = '';
                    const steps = 40;
                    for (let i = 0; i <= steps; i++) {
                        const t = i / steps;
                        const angle = t * turns * 2 * Math.PI;
                        const radius = rad * (0.3 + 0.7 * t);
                        const x = radius * Math.cos(angle);
                        const y = radius * Math.sin(angle);
                        path += (i === 0 ? 'M' : 'L') + ` ${x.toFixed(1)} ${y.toFixed(1)}`;
                    }
                    sp.append('path').attr('d', path).attr('stroke', col).attr('stroke-width', turns === 2 ? 3 : 2).attr('fill', 'none').attr('opacity', turns === 2 ? 1 : 0.6).attr('stroke-linecap', 'round');
                }
                
                // Center dot
                sp.append('circle').attr('r', rad * 0.18).attr('fill', col).attr('filter', `drop-shadow(0 0 ${rad * 0.4}px ${col})`);
                
                // Text
                g.append('text').attr('class', 'bubble-label').attr('dy', '-0.2em').style('font-size', Math.min(rad / 1.6, isM ? 12 : 16) + 'px').text(d.symbol);
                g.append('text').attr('class', 'bubble-change').attr('dy', '1em').style('font-size', Math.min(rad / 2.2, isM ? 10 : 12) + 'px').text((d.change24h >= 0 ? '+' : '') + d.change24h.toFixed(1) + '%');
            });
            
            // Set positions immediately - no animation that might cause issues
            bubbles.attr('transform', d => `translate(${d.x}, ${d.y})`);
        }
        
        function updateBubbles() {
            d3.selectAll('.bubble-change').text(d => (d.change24h >= 0 ? '+' : '') + d.change24h.toFixed(1) + '%');
            d3.selectAll('.bubble-spiral').each(function(d) {
                const c = getColor(d.change24h);
                d3.select(this).style('color', c).selectAll('path').attr('stroke', c);
                d3.select(this).select('circle').attr('fill', c);
            });
        }
        
        function fmtNum(n) { if (n >= 1e9) return (n / 1e9).toFixed(2) + 'B'; if (n >= 1e6) return (n / 1e6).toFixed(2) + 'M'; if (n >= 1e3) return (n / 1e3).toFixed(2) + 'K'; return n.toFixed(2); }
        function fmtPrice(p) { if (p >= 1000) return p.toLocaleString('en-US', {maximumFractionDigits: 0}); if (p >= 1) return p.toFixed(2); return p.toFixed(4); }
        
        function generateChartData(price, change) {
            const data = []; let p = price / (1 + change / 100);
            for (let i = 0; i < 24; i++) { p *= (1 + (Math.random() - 0.5) * Math.abs(change) / 100 * 0.5); data.push(p); }
            data[23] = price; return data;
        }
        
        function showModal(d) {
            currentModalCoin = d.symbol;
            document.getElementById('modal-symbol').textContent = d.symbol;
            const ce = document.getElementById('modal-change');
            ce.textContent = (d.change24h >= 0 ? '+' : '') + d.change24h.toFixed(2) + '%';
            ce.className = 'coin-change ' + (d.change24h >= 0 ? 'positive' : 'negative');
            document.getElementById('modal-price').textContent = '$' + fmtPrice(d.price);
            document.getElementById('modal-volume').textContent = '$' + fmtNum(d.volume24h);
            document.getElementById('modal-high').textContent = '$' + fmtPrice(d.high24h);
            document.getElementById('modal-low').textContent = '$' + fmtPrice(d.low24h);
            document.getElementById('modal').classList.add('active');
            
            setTimeout(() => {
                const ctx = document.getElementById('priceChart').getContext('2d');
                const isPos = d.change24h >= 0;
                const color = isPos ? '#00ff41' : '#ff0040';
                if (priceChart) priceChart.destroy();
                priceChart = new Chart(ctx, {
                    type: 'line',
                    data: { labels: Array(24).fill('').map((_, i) => i + 'h'), datasets: [{ data: generateChartData(d.price, d.change24h), borderColor: color, backgroundColor: (ctx) => { const g = ctx.chart.ctx.createLinearGradient(0, 0, 0, 180); g.addColorStop(0, isPos ? 'rgba(0,255,65,0.3)' : 'rgba(255,0,64,0.3)'); g.addColorStop(1, 'rgba(0,0,0,0)'); return g; }, borderWidth: 2, fill: true, tension: 0.4, pointRadius: 0 }] },
                    options: { responsive: true, maintainAspectRatio: false, plugins: { legend: { display: false } }, scales: { x: { display: false }, y: { display: true, grid: { color: 'rgba(255,255,255,0.05)' }, ticks: { color: 'rgba(255,255,255,0.5)', font: { size: 10 }, callback: v => '$' + v.toFixed(2) } } } }
                });
            }, 50);
        }
        
        function updateModalData(coin) {
            if (!document.getElementById('modal').classList.contains('active')) return;
            document.getElementById('modal-price').textContent = '$' + fmtPrice(coin.price);
            document.getElementById('modal-high').textContent = '$' + fmtPrice(coin.high24h);
            document.getElementById('modal-low').textContent = '$' + fmtPrice(coin.low24h);
            document.getElementById('modal-volume').textContent = '$' + fmtNum(coin.volume24h);
            const ce = document.getElementById('modal-change');
            ce.textContent = (coin.change24h >= 0 ? '+' : '') + coin.change24h.toFixed(2) + '%';
            ce.className = 'coin-change ' + (coin.change24h >= 0 ? 'positive' : 'negative');
        }
        
        function closeModal(e) { if (e.target === document.getElementById('modal')) { document.getElementById('modal').classList.remove('active'); currentModalCoin = null; } }
        document.addEventListener('keydown', (e) => { if (e.key === 'Escape') { document.getElementById('modal').classList.remove('active'); currentModalCoin = null; } });
        
        let touchStartY = 0;
        document.getElementById('modal').addEventListener('touchstart', (e) => { touchStartY = e.touches[0].clientY; });
        document.getElementById('modal').addEventListener('touchend', (e) => { if (e.changedTouches[0].clientY - touchStartY > 100) { document.getElementById('modal').classList.remove('active'); currentModalCoin = null; } });
        
        loadData();
        setInterval(loadData, 30000);
        window.addEventListener('resize', () => { if (!isFirstLoad) renderBubbles(); });
    </script>
</body>
</html>