        // Global state
        let bubbleData = [], isFirstLoad = true, currentSort = 'change';
        let ws = null, priceChart = null;
        let currentModalCoin = null;
        
        // Particle system
        const canvas = document.getElementById('particles-canvas');
        const ctx = canvas.getContext('2d');
        let particles = [];
        
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);
        
        class Particle {
            constructor() {
                this.reset();
            }
            reset() {
                this.x = Math.random() * canvas.width;
                this.y = Math.random() * canvas.height;
                this.size = Math.random() * 2 + 0.5;
                this.speedX = (Math.random() - 0.5) * 0.5;
                this.speedY = (Math.random() - 0.5) * 0.5;
                this.color = Math.random() > 0.5 ? 'rgba(0, 255, 65, ' : 'rgba(255, 0, 64, ';
                this.alpha = Math.random() * 0.5 + 0.1;
                this.life = Math.random() * 100 + 50;
            }
            update() {
                this.x += this.speedX;
                this.y += this.speedY;
                this.life--;
                if (this.life <= 0 || this.x < 0 || this.x > canvas.width || this.y < 0 || this.y > canvas.height) {
                    this.reset();
                }
            }
            draw() {
                ctx.fillStyle = this.color + this.alpha + ')';
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
            }
        }
        
        for (let i = 0; i < 50; i++) particles.push(new Particle());
        
        function animateParticles() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            particles.forEach(p => { p.update(); p.draw(); });
            requestAnimationFrame(animateParticles);
        }
        animateParticles();
        
        // WebSocket connection
        function connectWebSocket() {
            try {
                ws = new WebSocket('wss://stream.bybit.com/v5/public/linear');
                
                ws.onopen = () => {
                    console.log('WebSocket connected');
                    document.getElementById('ws-status').classList.add('connected');
                    // Subscribe to all USDT tickers
                    ws.send(JSON.stringify({
                        op: 'subscribe',
                        args: ['tickers.24h']
                    }));
                };
                
                ws.onmessage = (event) => {
                    const data = JSON.parse(event.data);
                    if (data.topic === 'tickers.24h' && data.data) {
                        updateFromWebSocket(data.data);
                    }
                };
                
                ws.onclose = () => {
                    console.log('WebSocket disconnected');
                    document.getElementById('ws-status').classList.remove('connected');
                    setTimeout(connectWebSocket, 5000); // Reconnect after 5s
                };
                
                ws.onerror = (error) => {
                    console.error('WebSocket error:', error);
                    ws.close();
                };
            } catch (e) {
                console.error('WebSocket init error:', e);
            }
        }
        
        function updateFromWebSocket(data) {
            let updated = false;
            data.forEach(ticker => {
                if (!ticker.symbol.endsWith('USDT')) return;
                const symbol = ticker.symbol.replace('USDT', '');
                const coin = bubbleData.find(c => c.symbol === symbol);
                if (coin) {
                    coin.change24h = parseFloat(ticker.price24hPcnt) * 100;
                    coin.price = parseFloat(ticker.lastPrice);
                    coin.volume24h = parseFloat(ticker.volume24h) * parseFloat(ticker.lastPrice);
                    coin.high24h = parseFloat(ticker.highPrice24h);
                    coin.low24h = parseFloat(ticker.lowPrice24h);
                    updated = true;
                    
                    // Update modal if open
                    if (currentModalCoin === symbol) {
                        updateModalData(coin);
                    }
                }
            });
            if (updated) {
                updateBubbles();
                updateTime();
            }
        }
        
        // API Data loading
        async function loadData() {
            if (isFirstLoad) document.getElementById('loading').style.display = 'block';
            try {
                const res = await fetch('https://api.bybit.com/v5/market/tickers?category=linear');
                const data = await res.json();
                if (data.retCode !== 0) throw new Error('API error');
                
                bubbleData = data.result.list
                    .filter(i => i.symbol.endsWith('USDT'))
                    .map(i => ({
                        symbol: i.symbol.replace('USDT', ''),
                        change24h: parseFloat(i.price24hPcnt) * 100,
                        price: parseFloat(i.lastPrice),
                        volume24h: parseFloat(i.volume24h) * parseFloat(i.lastPrice),
                        high24h: parseFloat(i.highPrice24h),
                        low24h: parseFloat(i.lowPrice24h)
                    }))
                    .filter(i => !isNaN(i.change24h));
                
                sortData();
                
                if (isFirstLoad) {
                    renderBubbles();
                    document.getElementById('loading').style.display = 'none';
                    document.getElementById('container').style.display = 'block';
                    isFirstLoad = false;
                    connectWebSocket(); // Connect WS after initial load
                } else {
                    updateBubbles();
                }
                updateTime();
            } catch (e) {
                console.error('Error:', e);
                document.getElementById('loading').style.display = 'none';
            }
        }
        
        // Sorting functions
        function setSort(type) {
            currentSort = type;
            document.querySelectorAll('.filter-btn').forEach(btn => btn.classList.remove('active'));
            document.getElementById('btn-' + type).classList.add('active');
            sortData();
            renderBubbles();
        }
        
        function sortData() {
            switch(currentSort) {
                case 'change':
                    bubbleData.sort((a, b) => Math.abs(b.change24h) - Math.abs(a.change24h));
                    break;
                case 'volume':
                    bubbleData.sort((a, b) => b.volume24h - a.volume24h);
                    break;
                case 'alpha':
                    bubbleData.sort((a, b) => a.symbol.localeCompare(b.symbol));
                    break;
            }
        }
        
        function updateTime() {
            document.getElementById('update-time').textContent = new Date().toLocaleTimeString('ro-RO', { 
                hour: '2-digit', 
                minute: '2-digit',
                second: '2-digit'
            });
        }
        
        function getColor(c) {
            return c >= 0 
                ? d3.interpolateRgb('#00ff41', '#39ff14')(Math.min(c / 20, 1))
                : d3.interpolateRgb('#ff0040', '#ff1744')(Math.min(Math.abs(c) / 20, 1));
        }
        
        function spiralPath(r, t) {
            let p = '';
            for (let i = 0; i <= 80; i++) {
                let x = i / 80;
                let a = x * t * 2 * Math.PI;
                let rad = r * (0.3 + 0.7 * x);
                let px = rad * Math.cos(a);
                let py = rad * Math.sin(a);
                p += (i === 0 ? 'M' : 'L') + ` ${px.toFixed(2)} ${py.toFixed(2)}`;
            }
            return p;
        }
        
        // Generate mock historical data for chart
        function generateChartData(currentPrice, change24h) {
            const points = 24;
            const data = [];
            let price = currentPrice / (1 + change24h / 100);
            const volatility = Math.abs(change24h) / 100 * 0.5;
            
            for (let i = 0; i < points; i++) {
                const randomChange = (Math.random() - 0.5) * volatility;
                price = price * (1 + randomChange);
                data.push(price);
            }
            data[data.length - 1] = currentPrice; // Ensure last point matches
            return data;
        }
        
        // Chart initialization
        function initChart(coin) {
            const ctx = document.getElementById('priceChart').getContext('2d');
            const isPositive = coin.change24h >= 0;
            const chartData = generateChartData(coin.price, coin.change24h);
            const color = isPositive ? '#00ff41' : '#ff0040';
            
            if (priceChart) {
                priceChart.destroy();
            }
            
            priceChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: Array(24).fill('').map((_, i) => `${i}h`),
                    datasets: [{
                        label: 'Price',
                        data: chartData,
                        borderColor: color,
                        backgroundColor: (context) => {
                            const ctx = context.chart.ctx;
                            const gradient = ctx.createLinearGradient(0, 0, 0, 200);
                            gradient.addColorStop(0, isPositive ? 'rgba(0, 255, 65, 0.3)' : 'rgba(255, 0, 64, 0.3)');
                            gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
                            return gradient;
                        },
                        borderWidth: 3,
                        fill: true,
                        tension: 0.4,
                        pointRadius: 0,
                        pointHoverRadius: 6,
                        pointHoverBackgroundColor: color,
                        pointHoverBorderColor: '#fff',
                        pointHoverBorderWidth: 2
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            backgroundColor: 'rgba(10, 10, 15, 0.95)',
                            titleColor: '#fff',
                            bodyColor: '#fff',
                            borderColor: color,
                            borderWidth: 1,
                            padding: 12,
                            displayColors: false,
                            callbacks: {
                                label: (context) => '$' + context.parsed.y.toFixed(4)
                            }
                        }
                    },
                    scales: {
                        x: { display: false },
                        y: {
                            display: true,
                            grid: {
                                color: 'rgba(255, 255, 255, 0.05)',
                                drawBorder: false
                            },
                            ticks: {
                                color: 'rgba(255, 255, 255, 0.5)',
                                font: { family: 'Rajdhani', size: 10 },
                                callback: (value) => '$' + value.toFixed(2)
                            }
                        }
                    },
                    interaction: {
                        intersect: false,
                        mode: 'index'
                    }
                }
            });
        }
        
        function renderBubbles() {
            const w = document.getElementById('bubble-container').clientWidth || window.innerWidth;
            const isM = w < 768;
            d3.select('#bubble-container').selectAll('*').remove();
            
            // Take top 20 gainers and 20 losers
            const gainers = bubbleData.filter(d => d.change24h >= 0).slice(0, 20);
            const losers = bubbleData.filter(d => d.change24h < 0).slice(0, 20);
            
            const baseRadius = isM ? 18 : 28;
            
            function placeBubblesOrganic(coins, startX, isGainers) {
                return coins.map((d, i) => {
                    const row = Math.floor(i / 5);
                    const col = i % 5;
                    const offsetX = (Math.random() - 0.5) * 30;
                    const offsetY = (Math.random() - 0.5) * 20;
                    
                    const spacing = isM ? 65 : 90;
                    const x = startX + col * spacing + offsetX;
                    const y = 100 + row * spacing + offsetY;
                    
                    const sizeBonus = Math.min(Math.abs(d.change24h) / 30, 1) * 12;
                    
                    return { ...d, x, y, r: baseRadius + sizeBonus };
                });
            }
            
            const gainersNodes = placeBubblesOrganic(gainers, isM ? 35 : 80, true);
            const losersNodes = placeBubblesOrganic(losers, isM ? w - 280 : w - 450, false);
            
            const all = [...gainersNodes, ...losersNodes];
            const h = Math.max(window.innerHeight, Math.ceil(20 / 5) * (isM ? 70 : 100) + 150);
            
            const svg = d3.select('#bubble-container').append('svg').attr('width', w).attr('height', h);
            
            // Collision simulation
            const sim = d3.forceSimulation(all)
                .force('charge', d3.forceManyBody().strength(isM ? -5 : -10))
                .force('collide', d3.forceCollide().radius(d => d.r + 8).strength(0.6))
                .force('x', d3.forceX(d => d.x).strength(0.05))
                .force('y', d3.forceY(d => d.y).strength(0.05))
                .stop();
            
            for (let i = 0; i < 100; i++) sim.tick();
            
            const bubbles = svg.selectAll('.bubble-group')
                .data(all)
                .enter()
                .append('g')
                .attr('class', 'bubble-group bubble-enter')
                .style('animation-delay', (d, i) => `${i * 0.03}s`)
                .on('click', (e, d) => showModal(d));
            
            bubbles.each(function(d) {
                const g = d3.select(this);
                const col = getColor(d.change24h);
                const rad = d.r;
                
                // Outer glow circle
                g.append('circle')
                    .attr('r', rad + 12)
                    .attr('fill', d3.color(col).copy({opacity: 0.08}))
                    .attr('class', 'glow-circle');
                
                // Main spiral
                const sp = g.append('g').attr('class', 'bubble-spiral').style('color', col);
                
                // Multiple spiral paths for depth
                sp.selectAll('.spiral-path')
                    .data([
                        {r: 0.95, t: 3, c: 'outer', opacity: 0.3},
                        {r: 0.8, t: 2.5, c: '', opacity: 0.8},
                        {r: 0.6, t: 2, c: 'inner', opacity: 0.6}
                    ])
                    .enter()
                    .append('path')
                    .attr('class', d => `spiral-path ${d.c}`)
                    .attr('d', d => spiralPath(rad * d.r, d.t))
                    .attr('stroke', col)
                    .attr('opacity', d => d.opacity);
                
                // Center dot
                sp.append('circle')
                    .attr('r', rad * 0.15)
                    .attr('fill', col)
                    .attr('opacity', 0.6)
                    .attr('filter', `drop-shadow(0 0 ${rad * 0.3}px ${col})`);
                
                // Symbol text
                g.append('text')
                    .attr('class', 'bubble-label')
                    .attr('dy', '-0.15em')
                    .style('font-size', Math.min(rad / 2, isM ? 11 : 14) + 'px')
                    .style('letter-spacing', '1px')
                    .text(d.symbol);
                
                // Change text
                g.append('text')
                    .attr('class', 'bubble-change')
                    .attr('dy', '0.9em')
                    .style('font-size', Math.min(rad / 2.8, isM ? 9 : 11) + 'px')
                    .text((d.change24h >= 0 ? '+' : '') + d.change24h.toFixed(1) + '%');
            });
            
            bubbles.attr('transform', d => `translate(${d.x.toFixed(1)},${d.y.toFixed(1)})`);
        }
        
        function updateBubbles() {
            d3.selectAll('.bubble-change').text(d => (d.change24h >= 0 ? '+' : '') + d.change24h.toFixed(1) + '%');
            d3.selectAll('.bubble-spiral').each(function(d) {
                const c = getColor(d.change24h);
                d3.select(this)
                    .style('color', c)
                    .selectAll('path')
                    .attr('stroke', c);
                d3.select(this).select('circle')
                    .attr('fill', c)
                    .attr('filter', `drop-shadow(0 0 ${d.r * 0.3}px ${c})`);
            });
            d3.selectAll('.glow-circle').attr('fill', d => d3.color(getColor(d.change24h)).copy({opacity: 0.08}));
        }
        
        function fmtNum(n) {
            if (n >= 1e9) return (n / 1e9).toFixed(2) + 'B';
            if (n >= 1e6) return (n / 1e6).toFixed(2) + 'M';
            if (n >= 1e3) return (n / 1e3).toFixed(2) + 'K';
            return n.toFixed(2);
        }
        
        function fmtPrice(p) {
            if (p >= 1000) return p.toLocaleString('en-US', {maximumFractionDigits: 0});
            if (p >= 1) return p.toFixed(2);
            return p.toFixed(4);
        }
        
        function showModal(d) {
            currentModalCoin = d.symbol;
            document.getElementById('modal-symbol').textContent = d.symbol;
            
            const ce = document.getElementById('modal-change');
            ce.textContent = (d.change24h >= 0 ? '+' : '') + d.change24h.toFixed(2) + '%';
            ce.className = 'coin-change ' + (d.change24h >= 0 ? 'positive' : 'negative');
            
            document.getElementById('modal-price').textContent = '$' + fmtPrice(d.price);
            document.getElementById('modal-volume').textContent = '$' + fmtNum(d.volume24h);
            document.getElementById('modal-high').textContent = '$' + fmtPrice(d.high24h);
            document.getElementById('modal-low').textContent = '$' + fmtPrice(d.low24h);
            
            document.getElementById('modal').classList.add('active');
            
            // Initialize chart
            setTimeout(() => initChart(d), 100);
        }
        
        function updateModalData(coin) {
            if (!document.getElementById('modal').classList.contains('active')) return;
            
            document.getElementById('modal-price').textContent = '$' + fmtPrice(coin.price);
            document.getElementById('modal-high').textContent = '$' + fmtPrice(coin.high24h);
            document.getElementById('modal-low').textContent = '$' + fmtPrice(coin.low24h);
            document.getElementById('modal-volume').textContent = '$' + fmtNum(coin.volume24h);
            
            const ce = document.getElementById('modal-change');
            ce.textContent = (coin.change24h >= 0 ? '+' : '') + coin.change24h.toFixed(2) + '%';
            ce.className = 'coin-change ' + (coin.change24h >= 0 ? 'positive' : 'negative');
            
            // Update chart with new data
            if (priceChart) {
                const isPositive = coin.change24h >= 0;
                const color = isPositive ? '#00ff41' : '#ff0040';
                const chartData = generateChartData(coin.price, coin.change24h);
                
                priceChart.data.datasets[0].data = chartData;
                priceChart.data.datasets[0].borderColor = color;
                priceChart.data.datasets[0].pointHoverBackgroundColor = color;
                priceChart.options.plugins.tooltip.borderColor = color;
                priceChart.update('none');
            }
        }
        
        function closeModal(e) {
            if (e.target === document.getElementById('modal')) {
                document.getElementById('modal').classList.remove('active');
                currentModalCoin = null;
            }
        }
        
        // Keyboard navigation
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                document.getElementById('modal').classList.remove('active');
                currentModalCoin = null;
            }
        });
        
        // Swipe to close modal
        let touchStartY = 0;
        document.getElementById('modal').addEventListener('touchstart', (e) => {
            touchStartY = e.touches[0].clientY;
        });
        
        document.getElementById('modal').addEventListener('touchend', (e) => {
            const touchEndY = e.changedTouches[0].clientY;
            if (touchEndY - touchStartY > 100) {
                document.getElementById('modal').classList.remove('active');
                currentModalCoin = null;
            }
        });
        
        // Initialize
        loadData();
        setInterval(loadData, 30000); // Fallback API poll
    </script>
</body>
</html>