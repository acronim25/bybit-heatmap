<!DOCTYPE html>
<html lang="ro">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>BYBIT HEATMAP | Guap üí∞</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;500;700;900&family=Rajdhani:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
        :root { 
            --neon-green: #00ff41; --neon-green-glow: rgba(0, 255, 65, 0.4);
            --neon-red: #ff0040; --neon-red-glow: rgba(255, 0, 64, 0.4);
            --accent-gold: #ffd700; --bg-dark: #050508; --bg-mid: #0a0a0f;
        }
        html, body { font-family: 'Rajdhani', sans-serif; background: var(--bg-dark); min-height: 100vh; color: #fff; overflow-x: hidden; }
        body::before {
            content: ''; position: fixed; top: 0; left: 0; right: 0; bottom: 0;
            background: linear-gradient(90deg, rgba(0, 255, 65, 0.03) 1px, transparent 1px), linear-gradient(rgba(0, 255, 65, 0.03) 1px, transparent 1px), repeating-linear-gradient(0deg, transparent, transparent 3px, rgba(255, 0, 64, 0.02) 3px, rgba(255, 0, 64, 0.02) 6px), radial-gradient(ellipse at 20% 30%, rgba(0, 255, 65, 0.05) 0%, transparent 50%), radial-gradient(ellipse at 80% 70%, rgba(255, 0, 64, 0.05) 0%, transparent 50%), var(--bg-dark);
            background-size: 60px 60px, 60px 60px, 100% 100%, 100% 100%, 100% 100%, 100% 100%;
            animation: bgPulse 8s ease-in-out infinite; z-index: -2;
        }
        @keyframes bgPulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.95; } }
        #particles-canvas { position: fixed; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: -1; }
        .scan-line { position: fixed; top: 0; left: 0; right: 0; height: 4px; background: linear-gradient(90deg, transparent, var(--neon-green), transparent); opacity: 0.3; animation: scanDown 6s linear infinite; pointer-events: none; z-index: 1000; }
        @keyframes scanDown { 0% { top: -4px; } 100% { top: 100vh; } }
        .header { position: fixed; top: 0; left: 0; right: 0; padding: 12px 16px; background: linear-gradient(180deg, rgba(10,10,15,0.98), rgba(10,10,15,0.8) 60%, transparent); z-index: 100; display: flex; justify-content: space-between; align-items: center; backdrop-filter: blur(10px); border-bottom: 1px solid rgba(0, 255, 65, 0.1); box-shadow: 0 2px 20px rgba(0, 255, 65, 0.1); }
        .logo { font-family: 'Orbitron', sans-serif; font-size: 1.1rem; font-weight: 700; letter-spacing: 3px; background: linear-gradient(135deg, #fff, var(--accent-gold), #fff); background-size: 200% 200%; -webkit-background-clip: text; -webkit-text-fill-color: transparent; animation: shimmer 3s ease-in-out infinite; }
        @keyframes shimmer { 0%, 100% { background-position: 0% 50%; } 50% { background-position: 100% 50%; } }
        .header-controls { display: flex; gap: 8px; align-items: center; }
        .filter-btn { background: rgba(0, 255, 65, 0.1); border: 1px solid rgba(0, 255, 65, 0.3); color: var(--neon-green); padding: 6px 12px; border-radius: 20px; font-family: 'Rajdhani', sans-serif; font-size: 0.75rem; font-weight: 600; cursor: pointer; transition: all 0.3s ease; text-transform: uppercase; letter-spacing: 1px; }
        .filter-btn:hover, .filter-btn.active { background: rgba(0, 255, 65, 0.25); box-shadow: 0 0 15px rgba(0, 255, 65, 0.3); }
        .filter-btn.red { background: rgba(255, 0, 64, 0.1); border-color: rgba(255, 0, 64, 0.3); color: var(--neon-red); }
        .filter-btn.red:hover, .filter-btn.red.active { background: rgba(255, 0, 64, 0.25); box-shadow: 0 0 15px rgba(255, 0, 64, 0.3); }
        .last-update { font-size: 0.75rem; color: rgba(255,255,255,0.5); display: flex; align-items: center; gap: 6px; }
        .update-dot { width: 8px; height: 8px; background: var(--neon-green); border-radius: 50%; animation: pulse 1.5s ease-in-out infinite; box-shadow: 0 0 10px var(--neon-green); }
        .ws-status { width: 8px; height: 8px; border-radius: 50%; background: #666; transition: all 0.3s; }
        .ws-status.connected { background: var(--neon-green); box-shadow: 0 0 10px var(--neon-green); animation: pulse 1s ease-in-out infinite; }
        @keyframes pulse { 0%, 100% { opacity: 1; transform: scale(1); } 50% { opacity: 0.6; transform: scale(1.1); } }
        .container { padding-top: 70px; }
        #bubble-container { width: 100%; overflow-x: hidden; min-height: 100vh; }
        .bubble-group { cursor: pointer; transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275); }
        .bubble-group:hover { transform: scale(1.15) translateY(-5px); z-index: 10; }
        .bubble-spiral { filter: drop-shadow(0 0 12px currentColor); transition: all 0.3s ease; animation: float 4s ease-in-out infinite; }
        @keyframes float { 0%, 100% { transform: translateY(0) rotate(0deg); } 25% { transform: translateY(-3px) rotate(90deg); } 50% { transform: translateY(0) rotate(180deg); } 75% { transform: translateY(3px) rotate(270deg); } 100% { transform: translateY(0) rotate(360deg); } }
        .bubble-group:hover .bubble-spiral { filter: drop-shadow(0 0 30px currentColor) brightness(1.5); animation: pulseGlow 0.5s ease-in-out infinite alternate; }
        @keyframes pulseGlow { from { filter: drop-shadow(0 0 20px currentColor) brightness(1.3); } to { filter: drop-shadow(0 0 40px currentColor) brightness(1.7); } }
        .spiral-path { fill: none; stroke-width: 4; stroke-linecap: round; stroke-dasharray: 200; stroke-dashoffset: 0; animation: drawSpiral 2s ease-out; }
        @keyframes drawSpiral { from { stroke-dashoffset: 200; } to { stroke-dashoffset: 0; } }
        .spiral-path.inner { stroke-width: 2.5; opacity: 0.7; }
        .spiral-path.outer { stroke-width: 1.5; opacity: 0.4; }
        .bubble-label { font-family: 'Orbitron', sans-serif; font-weight: 700; text-anchor: middle; pointer-events: none; fill: #fff; text-shadow: 0 0 15px rgba(0,0,0,0.9), 0 0 30px currentColor; }
        .bubble-change { font-family: 'Rajdhani', sans-serif; font-weight: 600; text-anchor: middle; pointer-events: none; fill: #fff; text-shadow: 0 0 10px rgba(0,0,0,0.9); }
        .bubble-enter { animation: bubbleEnter 0.6s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards; opacity: 0; transform: scale(0); }
        @keyframes bubbleEnter { to { opacity: 1; transform: scale(1); } }
        .loading { position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); text-align: center; z-index: 50; }
        .loading-spinner { width: 60px; height: 60px; border: 3px solid rgba(0,255,65,0.2); border-top-color: var(--neon-green); border-right-color: var(--neon-green); border-radius: 50%; animation: spin 1s linear infinite; margin: 0 auto 20px; box-shadow: 0 0 20px rgba(0, 255, 65, 0.3); }
        @keyframes spin { to { transform: rotate(360deg); } }
        .modal-overlay { position: fixed; inset: 0; background: rgba(5, 5, 8, 0.95); backdrop-filter: blur(20px); z-index: 1000; display: none; justify-content: center; align-items: flex-end; animation: fadeIn 0.3s ease; }
        @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
        .modal-overlay.active { display: flex; }
        .modal-content { background: linear-gradient(145deg, rgba(15,10,20,0.98), rgba(8,8,12,0.99)); border-radius: 30px 30px 0 0; padding: 30px 24px 50px; width: 100%; max-width: 500px; max-height: 85vh; border-top: 2px solid; border-image: linear-gradient(90deg, var(--neon-green), var(--neon-red)) 1; animation: slideUp 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275); overflow-y: auto; box-shadow: 0 -10px 50px rgba(0, 0, 0, 0.5); }
        @keyframes slideUp { from { transform: translateY(100%); opacity: 0; } to { transform: translateY(0); opacity: 1; } }
        .modal-handle { width: 50px; height: 5px; background: linear-gradient(90deg, rgba(0,255,65,0.5), rgba(255,0,64,0.5)); border-radius: 3px; margin: 0 auto 25px; }
        .coin-header { text-align: center; margin-bottom: 30px; padding-bottom: 20px; border-bottom: 1px solid rgba(255,255,255,0.1); }
        .coin-symbol { font-family: 'Orbitron', sans-serif; font-size: 2.2rem; font-weight: 900; letter-spacing: 4px; background: linear-gradient(135deg, #fff, var(--accent-gold)); -webkit-background-clip: text; -webkit-text-fill-color: transparent; }
        .coin-change { font-family: 'Orbitron', sans-serif; font-size: 2.8rem; font-weight: 700; margin-top: 12px; text-shadow: 0 0 30px currentColor; }
        .coin-change.positive { color: var(--neon-green); text-shadow: 0 0 30px var(--neon-green-glow); }
        .coin-change.negative { color: var(--neon-red); text-shadow: 0 0 30px var(--neon-red-glow); }
        .chart-container { width: 100%; height: 200px; margin: 20px 0; background: rgba(255,255,255,0.02); border-radius: 16px; padding: 15px; border: 1px solid rgba(255,255,255,0.05); }
        .stats-grid { display: grid; grid-template-columns: repeat(2, 1fr); gap: 15px; margin-top: 20px; }
        .stat-item { background: rgba(255,255,255,0.03); padding: 20px; border-radius: 16px; border: 1px solid rgba(255,255,255,0.08); transition: all 0.3s ease; }
        .stat-item:hover { background: rgba(255,255,255,0.05); border-color: rgba(0, 255, 65, 0.2); transform: translateY(-2px); }
        .stat-label { font-size: 0.7rem; color: rgba(255,255,255,0.4); text-transform: uppercase; letter-spacing: 2px; margin-bottom: 8px; }
        .stat-value { font-family: 'Orbitron', sans-serif; font-size: 1.1rem; font-weight: 600; color: #fff; }
        @media (max-width: 768px) { .header { padding: 10px 12px; } .logo { font-size: 0.9rem; } .header-controls { gap: 4px; } .filter-btn { padding: 4px 8px; font-size: 0.65rem; } .coin-symbol { font-size: 1.8rem; } .coin-change { font-size: 2.2rem; } .chart-container { height: 150px; } }
    </style>
</head>
<body>
    <div class="scan-line"></div>
    <canvas id="particles-canvas"></canvas>
    <div class="header">
        <div class="logo">üí∞ BYBIT</div>
        <div class="header-controls">
            <button class="filter-btn active" onclick="setSort('change')" id="btn-change">% CHANGE</button>
            <button class="filter-btn" onclick="setSort('volume')" id="btn-volume">VOLUME</button>
            <button class="filter-btn" onclick="setSort('alpha')" id="btn-alpha">A-Z</button>
        </div>
        <div class="last-update">
            <div class="ws-status" id="ws-status" title="WebSocket Status"></div>
            <span class="update-dot"></span>
            <span id="update-time">--:--</span>
        </div>
    </div>
    <div class="loading" id="loading">
        <div class="loading-spinner"></div>
        <div style="color: rgba(255,255,255,0.5); font-size: 0.9rem;">Loading market data...</div>
    </div>
    <div class="container" id="container" style="display: none;">
        <div id="bubble-container"></div>
    </div>
    <div class="modal-overlay" id="modal" onclick="closeModal(event)">
        <div class="modal-content" onclick="event.stopPropagation()">
            <div class="modal-handle"></div>
            <div class="coin-header">
                <div class="coin-symbol" id="modal-symbol">BTC</div>
                <div class="coin-change" id="modal-change">+5.23%</div>
            </div>
            <div class="chart-container">
                <canvas id="priceChart"></canvas>
            </div>
            <div class="stats-grid">
                <div class="stat-item">
                    <div class="stat-label">Pre»õ</div>
                    <div class="stat-value" id="modal-price">-</div>
                </div>
                <div class="stat-item">
                    <div class="stat-label">Volum 24h</div>
                    <div class="stat-value" id="modal-volume">-</div>
                </div>
                <div class="stat-item">
                    <div class="stat-label">Max 24h</div>
                    <div class="stat-value" id="modal-high">-</div>
                </div>
                <div class="stat-item">
                    <div class="stat-label">Min 24h</div>
                    <div class="stat-value" id="modal-low">-</div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Global state
        let bubbleData = [], isFirstLoad = true, currentSort = 'change';
        let ws = null, priceChart = null;
        let currentModalCoin = null;
        
        // Particle system
        const canvas = document.getElementById('particles-canvas');
        const ctx = canvas.getContext('2d');
        let particles = [];
        
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);
        
        class Particle {
            constructor() {
                this.reset();
            }
            reset() {
                this.x = Math.random() * canvas.width;
                this.y = Math.random() * canvas.height;
                this.size = Math.random() * 2 + 0.5;
                this.speedX = (Math.random() - 0.5) * 0.5;
                this.speedY = (Math.random() - 0.5) * 0.5;
                this.color = Math.random() > 0.5 ? 'rgba(0, 255, 65, ' : 'rgba(255, 0, 64, ';
                this.alpha = Math.random() * 0.5 + 0.1;
                this.life = Math.random() * 100 + 50;
            }
            update() {
                this.x += this.speedX;
                this.y += this.speedY;
                this.life--;
                if (this.life <= 0 || this.x < 0 || this.x > canvas.width || this.y < 0 || this.y > canvas.height) {
                    this.reset();
                }
            }
            draw() {
                ctx.fillStyle = this.color + this.alpha + ')';
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
            }
        }
        
        for (let i = 0; i < 50; i++) particles.push(new Particle());
        
        function animateParticles() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            particles.forEach(p => { p.update(); p.draw(); });
            requestAnimationFrame(animateParticles);
        }
        animateParticles();
        
        // WebSocket connection
        function connectWebSocket() {
            try {
                ws = new WebSocket('wss://stream.bybit.com/v5/public/linear');
                
                ws.onopen = () => {
                    console.log('WebSocket connected');
                    document.getElementById('ws-status').classList.add('connected');
                    ws.send(JSON.stringify({ op: 'subscribe', args: ['tickers.24h'] }));
                };
                
                ws.onmessage = (event) => {
                    const data = JSON.parse(event.data);
                    if (data.topic === 'tickers.24h' && data.data) {
                        updateFromWebSocket(data.data);
                    }
                };
                
                ws.onclose = () => {
                    console.log('WebSocket disconnected');
                    document.getElementById('ws-status').classList.remove('connected');
                    setTimeout(connectWebSocket, 5000);
                };
                
                ws.onerror = (error) => {
                    console.error('WebSocket error:', error);
                    ws.close();
                };
            } catch (e) {
                console.error('WebSocket init error:', e);
            }
        }
        
        function updateFromWebSocket(data) {
            let updated = false;
            data.forEach(ticker => {
                if (!ticker.symbol.endsWith('USDT')) return;
                const symbol = ticker.symbol.replace('USDT', '');
                const coin = bubbleData.find(c => c.symbol === symbol);
                if (coin) {
                    coin.change24h = parseFloat(ticker.price24hPcnt) * 100;
                    coin.price = parseFloat(ticker.lastPrice);
                    coin.volume24h = parseFloat(ticker.volume24h) * parseFloat(ticker.lastPrice);
                    coin.high24h = parseFloat(ticker.highPrice24h);
                    coin.low24h = parseFloat(ticker.lowPrice24h);
                    updated = true;
                    if (currentModalCoin === symbol) {
                        updateModalData(coin);
                    }
                }
            });
            if (updated) {
                updateBubbles();
                updateTime();
            }
        }
        
        async function loadData() {
            if (isFirstLoad) {
                document.getElementById('loading').style.display = 'block';
                document.getElementById('loading').innerHTML = `
                    <div class="loading-spinner"></div>
                    <div style="color: rgba(255,255,255,0.5); font-size: 0.9rem;">Loading market data...</div>
                `;
            }
            try {
                const res = await fetch('https://api.bybit.com/v5/market/tickers?category=linear');
                const data = await res.json();
                if (data.retCode !== 0) throw new Error('API error: ' + data.retMsg);
                
                const rawData = data.result.list
                    .filter(i => i.symbol.endsWith('USDT'))
                    .map(i => ({
                        symbol: i.symbol.replace('USDT', ''),
                        change24h: parseFloat(i.price24hPcnt) * 100,
                        price: parseFloat(i.lastPrice),
                        volume24h: parseFloat(i.volume24h) * parseFloat(i.lastPrice),
                        high24h: parseFloat(i.highPrice24h),
                        low24h: parseFloat(i.lowPrice24h)
                    }))
                    .filter(i => !isNaN(i.change24h) && i.price > 0);
                
                if (rawData.length === 0) throw new Error('No valid data');
                
                bubbleData = rawData;
                
                // Sort by absolute change by default
                bubbleData.sort((a, b) => Math.abs(b.change24h) - Math.abs(a.change24h));
                
                if (isFirstLoad) {
                    document.getElementById('loading').style.display = 'none';
                    document.getElementById('container').style.display = 'block';
                    renderBubbles();
                    isFirstLoad = false;
                    connectWebSocket();
                } else {
                    updateBubbles();
                }
                updateTime();
            } catch (e) {
                console.error('Error loading data:', e);
                document.getElementById('loading').innerHTML = `
                    <div style="color: #ff0040; font-size: 1rem; text-align: center;">
                        <div style="margin-bottom: 10px;">‚ö†Ô∏è Error loading data</div>
                        <div style="font-size: 0.8rem; color: rgba(255,255,255,0.5);">${e.message}</div>
                        <button onclick="loadData()" style="margin-top: 15px; padding: 10px 20px; background: rgba(0,255,65,0.2); border: 1px solid #00ff41; color: #00ff41; border-radius: 20px; cursor: pointer;">Retry</button>
                    </div>
                `;
            }
        }
        
        function setSort(type) {
            currentSort = type;
            document.querySelectorAll('.filter-btn').forEach(btn => btn.classList.remove('active'));
            document.getElementById('btn-' + type).classList.add('active');
            sortData();
            renderBubbles();
        }
        
        function sortData() {
            switch(currentSort) {
                case 'change':
                    bubbleData.sort((a, b) => Math.abs(b.change24h) - Math.abs(a.change24h));
                    break;
                case 'volume':
                    bubbleData.sort((a, b) => b.volume24h - a.volume24h);
                    break;
                case 'alpha':
                    bubbleData.sort((a, b) => a.symbol.localeCompare(b.symbol));
                    break;
            }
        }
        
        function updateTime() {
            document.getElementById('update-time').textContent = new Date().toLocaleTimeString('ro-RO', { 
                hour: '2-digit', minute: '2-digit', second: '2-digit'
            });
        }
        
        function getColor(c) {
            return c >= 0 
                ? d3.interpolateRgb('#00ff41', '#39ff14')(Math.min(c / 20, 1))
                : d3.interpolateRgb('#ff0040', '#ff1744')(Math.min(Math.abs(c) / 20, 1));
        }
        
        function spiralPath(r, t) {
            let p = '';
            for (let i = 0; i <= 80; i++) {
                let x = i / 80;
                let a = x * t * 2 * Math.PI;
                let rad = r * (0.3 + 0.7 * x);
                let px = rad * Math.cos(a);
                let py = rad * Math.sin(a);
                p += (i === 0 ? 'M' : 'L') + ` ${px.toFixed(2)} ${py.toFixed(2)}`;
            }
            return p;
        }
        
        function generateChartData(currentPrice, change24h) {
            const points = 24;
            const data = [];
            let price = currentPrice / (1 + change24h / 100);
            const volatility = Math.abs(change24h) / 100 * 0.5;
            
            for (let i = 0; i < points; i++) {
                const randomChange = (Math.random() - 0.5) * volatility;
                price = price * (1 + randomChange);
                data.push(price);
            }
            data[data.length - 1] = currentPrice;
            return data;
        }
        
        function initChart(coin) {
            const ctx = document.getElementById('priceChart').getContext('2d');
            const isPositive = coin.change24h >= 0;
            const chartData = generateChartData(coin.price, coin.change24h);
            const color = isPositive ? '#00ff41' : '#ff0040';
            
            if (priceChart) {
                priceChart.destroy();
            }
            
            priceChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: Array(24).fill('').map((_, i) => `${i}h`),
                    datasets: [{
                        label: 'Price',
                        data: chartData,
                        borderColor: color,
                        backgroundColor: (context) => {
                            const ctx = context.chart.ctx;
                            const gradient = ctx.createLinearGradient(0, 0, 0, 200);
                            gradient.addColorStop(0, isPositive ? 'rgba(0, 255, 65, 0.3)' : 'rgba(255, 0, 64, 0.3)');
                            gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
                            return gradient;
                        },
                        borderWidth: 3,
                        fill: true,
                        tension: 0.4,
                        pointRadius: 0,
                        pointHoverRadius: 6,
                        pointHoverBackgroundColor: color,
                        pointHoverBorderColor: '#fff',
                        pointHoverBorderWidth: 2
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            backgroundColor: 'rgba(10, 10, 15, 0.95)',
                            titleColor: '#fff',
                            bodyColor: '#fff',
                            borderColor: color,
                            borderWidth: 1,
                            padding: 12,
                            displayColors: false,
                            callbacks: {
                                label: (context) => '$' + context.parsed.y.toFixed(4)
                            }
                        }
                    },
                    scales: {
                        x: { display: false },
                        y: {
                            display: true,
                            grid: { color: 'rgba(255, 255, 255, 0.05)', drawBorder: false },
                            ticks: {
                                color: 'rgba(255, 255, 255, 0.5)',
                                font: { family: 'Rajdhani', size: 10 },
                                callback: (value) => '$' + value.toFixed(2)
                            }
                        }
                    },
                    interaction: { intersect: false, mode: 'index' }
                }
            });
        }
        
        function renderBubbles() {
            const container = document.getElementById('bubble-container');
            const w = container.clientWidth || window.innerWidth;
            const h = Math.max(window.innerHeight, 800);
            const isM = w < 768;
            
            // Clear existing
            d3.select('#bubble-container').selectAll('*').remove();
            
            if (bubbleData.length === 0) {
                console.warn('No data to render');
                return;
            }
            
            // Get gainers and losers
            const gainers = bubbleData.filter(d => d.change24h >= 0).slice(0, 20);
            const losers = bubbleData.filter(d => d.change24h < 0).slice(0, 20);
            
            const baseRadius = isM ? 25 : 35;
            
            // Position gainers on LEFT side
            const gainersNodes = gainers.map((d, i) => {
                const col = i % 4;
                const row = Math.floor(i / 4);
                const spacingX = isM ? 80 : 110;
                const spacingY = isM ? 90 : 120;
                const startX = isM ? 60 : 150;
                const x = startX + col * spacingX + (Math.random() - 0.5) * 30;
                const y = 140 + row * spacingY + (Math.random() - 0.5) * 25;
                const sizeBonus = Math.min(Math.abs(d.change24h) / 20, 1) * 15;
                return { ...d, x, y, r: baseRadius + sizeBonus, originalX: x, originalY: y };
            });
            
            // Position losers on RIGHT side
            const losersNodes = losers.map((d, i) => {
                const col = i % 4;
                const row = Math.floor(i / 4);
                const spacingX = isM ? 80 : 110;
                const spacingY = isM ? 90 : 120;
                const startX = isM ? w - 320 : w - 500;
                const x = startX + col * spacingX + (Math.random() - 0.5) * 30;
                const y = 140 + row * spacingY + (Math.random() - 0.5) * 25;
                const sizeBonus = Math.min(Math.abs(d.change24h) / 20, 1) * 15;
                return { ...d, x, y, r: baseRadius + sizeBonus, originalX: x, originalY: y };
            });
            
            const all = [...gainersNodes, ...losersNodes];
            
            console.log('Rendering', all.length, 'bubbles', 'Width:', w, 'Height:', h);
            
            const svg = d3.select('#bubble-container')
                .append('svg')
                .attr('width', w)
                .attr('height', h)
                .style('display', 'block');
            
            // Force simulation to prevent overlap but keep positions
            const simulation = d3.forceSimulation(all)
                .force('charge', d3.forceManyBody().strength(isM ? -10 : -20))
                .force('collide', d3.forceCollide().radius(d => d.r + 8).strength(0.8))
                .force('x', d3.forceX(d => d.originalX).strength(0.1))
                .force('y', d3.forceY(d => d.originalY).strength(0.1))
                .stop();
            
            // Run simulation for a few iterations
            for (let i = 0; i < 80; i++) simulation.tick();
            
            // Create bubble groups
            const bubbles = svg.selectAll('.bubble-group')
                .data(all)
                .enter()
                .append('g')
                .attr('class', 'bubble-group bubble-enter')
                .style('animation-delay', (d, i) => `${i * 0.025}s`)
                .on('click', (e, d) => showModal(d));
            
            bubbles.each(function(d) {
                const g = d3.select(this);
                const col = getColor(d.change24h);
                const rad = d.r;
                
                // Outer glow
                g.append('circle')
                    .attr('r', rad + 15)
                    .attr('fill', d3.color(col).copy({opacity: 0.1}))
                    .attr('class', 'glow-circle');
                
                // Spiral group
                const sp = g.append('g')
                    .attr('class', 'bubble-spiral')
                    .style('color', col);
                
                // Multiple spiral layers
                sp.selectAll('.spiral-path')
                    .data([
                        {r: 0.95, t: 3, c: 'outer', opacity: 0.3, width: 2},
                        {r: 0.75, t: 2.5, c: '', opacity: 1, width: 4},
                        {r: 0.55, t: 2, c: 'inner', opacity: 0.8, width: 2.5}
                    ])
                    .enter()
                    .append('path')
                    .attr('class', d => `spiral-path ${d.c}`)
                    .attr('d', d => spiralPath(rad * d.r, d.t))
                    .attr('stroke', col)
                    .attr('stroke-width', d => d.width)
                    .attr('opacity', d => d.opacity)
                    .attr('fill', 'none')
                    .attr('stroke-linecap', 'round');
                
                // Center dot
                sp.append('circle')
                    .attr('r', rad * 0.2)
                    .attr('fill', col)
                    .attr('opacity', 0.9)
                    .attr('filter', `drop-shadow(0 0 ${rad * 0.5}px ${col})`);
                
                // Symbol text
                g.append('text')
                    .attr('class', 'bubble-label')
                    .attr('dy', '-0.25em')
                    .style('font-size', Math.min(rad / 1.8, isM ? 13 : 18) + 'px')
                    .style('letter-spacing', '1px')
                    .style('font-weight', '700')
                    .text(d.symbol);
                
                // Change percentage
                g.append('text')
                    .attr('class', 'bubble-change')
                    .attr('dy', '1.1em')
                    .style('font-size', Math.min(rad / 2.5, isM ? 11 : 14) + 'px')
                    .style('font-weight', '600')
                    .text((d.change24h >= 0 ? '+' : '') + d.change24h.toFixed(1) + '%');
            });
            
            // Apply positions
            bubbles.attr('transform', d => `translate(${d.x.toFixed(1)}, ${d.y.toFixed(1)})`);
            
            console.log('Bubbles rendered - Gainers:', gainersNodes.length, 'Losers:', losersNodes.length);
        }
        
        function updateBubbles() {
            d3.selectAll('.bubble-change').text(d => (d.change24h >= 0 ? '+' : '') + d.change24h.toFixed(1) + '%');
            d3.selectAll('.bubble-spiral').each(function(d) {
                const c = getColor(d.change24h);
                d3.select(this).style('color', c).selectAll('path').attr('stroke', c);
                d3.select(this).select('circle').attr('fill', c).attr('filter', `drop-shadow(0 0 ${d.r * 0.3}px ${c})`);
            });
            d3.selectAll('.glow-circle').attr('fill', d => d3.color(getColor(d.change24h)).copy({opacity: 0.08}));
        }
        
        function fmtNum(n) {
            if (n >= 1e9) return (n / 1e9).toFixed(2) + 'B';
            if (n >= 1e6) return (n / 1e6).toFixed(2) + 'M';
            if (n >= 1e3) return (n / 1e3).toFixed(2) + 'K';
            return n.toFixed(2);
        }
        
        function fmtPrice(p) {
            if (p >= 1000) return p.toLocaleString('en-US', {maximumFractionDigits: 0});
            if (p >= 1) return p.toFixed(2);
            return p.toFixed(4);
        }
        
        function showModal(d) {
            currentModalCoin = d.symbol;
            document.getElementById('modal-symbol').textContent = d.symbol;
            const ce = document.getElementById('modal-change');
            ce.textContent = (d.change24h >= 0 ? '+' : '') + d.change24h.toFixed(2) + '%';
            ce.className = 'coin-change ' + (d.change24h >= 0 ? 'positive' : 'negative');
            document.getElementById('modal-price').textContent = '$' + fmtPrice(d.price);
            document.getElementById('modal-volume').textContent = '$' + fmtNum(d.volume24h);
            document.getElementById('modal-high').textContent = '$' + fmtPrice(d.high24h);
            document.getElementById('modal-low').textContent = '$' + fmtPrice(d.low24h);
            document.getElementById('modal').classList.add('active');
            setTimeout(() => initChart(d), 100);
        }
        
        function updateModalData(coin) {
            if (!document.getElementById('modal').classList.contains('active')) return;
            document.getElementById('modal-price').textContent = '$' + fmtPrice(coin.price);
            document.getElementById('modal-high').textContent = '$' + fmtPrice(coin.high24h);
            document.getElementById('modal-low').textContent = '$' + fmtPrice(coin.low24h);
            document.getElementById('modal-volume').textContent = '$' + fmtNum(coin.volume24h);
            const ce = document.getElementById('modal-change');
            ce.textContent = (coin.change24h >= 0 ? '+' : '') + coin.change24h.toFixed(2) + '%';
            ce.className = 'coin-change ' + (coin.change24h >= 0 ? 'positive' : 'negative');
            if (priceChart) {
                const isPositive = coin.change24h >= 0;
                const color = isPositive ? '#00ff41' : '#ff0040';
                const chartData = generateChartData(coin.price, coin.change24h);
                priceChart.data.datasets[0].data = chartData;
                priceChart.data.datasets[0].borderColor = color;
                priceChart.data.datasets[0].pointHoverBackgroundColor = color;
                priceChart.options.plugins.tooltip.borderColor = color;
                priceChart.update('none');
            }
        }
        
        function closeModal(e) {
            if (e.target === document.getElementById('modal')) {
                document.getElementById('modal').classList.remove('active');
                currentModalCoin = null;
            }
        }
        
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                document.getElementById('modal').classList.remove('active');
                currentModalCoin = null;
            }
        });
        
        let touchStartY = 0;
        document.getElementById('modal').addEventListener('touchstart', (e) => {
            touchStartY = e.touches[0].clientY;
        });
        
        document.getElementById('modal').addEventListener('touchend', (e) => {
            const touchEndY = e.changedTouches[0].clientY;
            if (touchEndY - touchStartY > 100) {
                document.getElementById('modal').classList.remove('active');
                currentModalCoin = null;
            }
        });
        
        loadData();
        setInterval(loadData, 30000);
    </script>
</body>
</html>