        // Global state
        let bubbleData = [], isFirstLoad = true, currentSort = 'change';
        let ws = null, priceChart = null, currentModalCoin = null;
        const BUBBLE_COUNT = 40; // 40 gainers + 40 losers = 80 total
        
        // Enhanced particle system
        const canvas = document.getElementById('particles-canvas');
        const ctx = canvas.getContext('2d');
        let particles = [];
        
        function resizeCanvas() { canvas.width = window.innerWidth; canvas.height = window.innerHeight; }
        resizeCanvas(); window.addEventListener('resize', () => { resizeCanvas(); if (!isFirstLoad) renderBubbles(); });
        
        class Particle {
            constructor() { this.reset(); }
            reset() {
                this.x = Math.random() * canvas.width;
                this.y = Math.random() * canvas.height;
                this.size = Math.random() * 3 + 1;
                this.speedX = (Math.random() - 0.5) * 0.8;
                this.speedY = (Math.random() - 0.5) * 0.8;
                this.color = Math.random() > 0.5 ? 'rgba(0, 255, 65, ' : 'rgba(255, 0, 64, ';
                this.alpha = Math.random() * 0.6 + 0.2;
                this.life = Math.random() * 150 + 100;
                this.pulse = Math.random() * Math.PI * 2;
            }
            update() {
                this.x += this.speedX;
                this.y += this.speedY;
                this.pulse += 0.05;
                this.life--;
                const pulseAlpha = this.alpha * (0.7 + 0.3 * Math.sin(this.pulse));
                if (this.life <= 0 || this.x < 0 || this.x > canvas.width || this.y < 0 || this.y > canvas.height) this.reset();
                return pulseAlpha;
            }
            draw() {
                const alpha = this.update();
                ctx.fillStyle = this.color + alpha + ')';
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
                // Glow effect
                ctx.fillStyle = this.color + (alpha * 0.3) + ')';
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size * 2, 0, Math.PI * 2);
                ctx.fill();
            }
        }
        
        // Create 100 particles
        for (let i = 0; i < 100; i++) particles.push(new Particle());
        
        function animateParticles() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            particles.forEach(p => p.draw());
            requestAnimationFrame(animateParticles);
        }
        animateParticles();
        
        // Create floating particles
        function createFloatParticles() {
            for (let i = 0; i < 15; i++) {
                const p = document.createElement('div');
                p.className = 'float-particle';
                p.style.left = Math.random() * 100 + '%';
                p.style.top = Math.random() * 100 + '%';
                p.style.animationDelay = Math.random() * 10 + 's';
                p.style.animationDuration = (8 + Math.random() * 6) + 's';
                document.body.appendChild(p);
            }
        }
        createFloatParticles();
        
        // WebSocket connection
        function connectWebSocket() {
            try {
                ws = new WebSocket('wss://stream.bybit.com/v5/public/linear');
                ws.onopen = () => {
                    document.getElementById('ws-status').classList.add('connected');
                    ws.send(JSON.stringify({ op: 'subscribe', args: ['tickers.24h'] }));
                };
                ws.onmessage = (event) => {
                    const data = JSON.parse(event.data);
                    if (data.topic === 'tickers.24h' && data.data) updateFromWebSocket(data.data);
                };
                ws.onclose = () => {
                    document.getElementById('ws-status').classList.remove('connected');
                    setTimeout(connectWebSocket, 5000);
                };
                ws.onerror = () => ws.close();
            } catch (e) {}
        }
        
        function updateFromWebSocket(data) {
            let updated = false;
            data.forEach(ticker => {
                if (!ticker.symbol.endsWith('USDT')) return;
                const symbol = ticker.symbol.replace('USDT', '');
                const coin = bubbleData.find(c => c.symbol === symbol);
                if (coin) {
                    coin.change24h = parseFloat(ticker.price24hPcnt) * 100;
                    coin.price = parseFloat(ticker.lastPrice);
                    coin.volume24h = parseFloat(ticker.volume24h) * parseFloat(ticker.lastPrice);
                    updated = true;
                    if (currentModalCoin === symbol) updateModalData(coin);
                }
            });
            if (updated) { updateBubbles(); updateTime(); updateStatsBar(); }
        }
        
        async function loadData() {
            if (isFirstLoad) document.getElementById('loading').style.display = 'block';
            try {
                const res = await fetch('https://api.bybit.com/v5/market/tickers?category=linear');
                const data = await res.json();
                if (data.retCode !== 0) throw new Error(data.retMsg);
                
                bubbleData = data.result.list
                    .filter(i => i.symbol.endsWith('USDT'))
                    .map(i => ({
                        symbol: i.symbol.replace('USDT', ''),
                        change24h: parseFloat(i.price24hPcnt) * 100,
                        price: parseFloat(i.lastPrice),
                        volume24h: parseFloat(i.volume24h) * parseFloat(i.lastPrice),
                        high24h: parseFloat(i.highPrice24h),
                        low24h: parseFloat(i.lowPrice24h)
                    }))
                    .filter(i => !isNaN(i.change24h) && i.price > 0);
                
                bubbleData.sort((a, b) => Math.abs(b.change24h) - Math.abs(a.change24h));
                
                if (isFirstLoad) {
                    document.getElementById('loading').style.display = 'none';
                    document.getElementById('container').style.display = 'block';
                    renderBubbles();
                    updateStatsBar();
                    isFirstLoad = false;
                    connectWebSocket();
                } else {
                    updateBubbles();
                    updateStatsBar();
                }
                updateTime();
            } catch (e) {
                document.getElementById('loading').innerHTML = `
                    <div style="color: #ff0040; text-align: center; padding: 20px;">
                        <div style="font-size: 1.2rem; margin-bottom: 10px;">‚ö†Ô∏è Error</div>
                        <div style="font-size: 0.9rem; color: rgba(255,255,255,0.6);">${e.message}</div>
                        <button onclick="loadData()" style="margin-top: 20px; padding: 12px 30px; background: rgba(0,255,65,0.2); border: 2px solid #00ff41; color: #00ff41; border-radius: 30px; cursor: pointer; font-family: Orbitron; font-weight: 600;">RETRY</button>
                    </div>`;
            }
        }
        
        function updateStatsBar() {
            const gainers = bubbleData.filter(d => d.change24h >= 0).length;
            const losers = bubbleData.filter(d => d.change24h < 0).length;
            const sentiment = gainers > losers ? 'BULLISH üìà' : gainers < losers ? 'BEARISH üìâ' : 'NEUTRAL ‚öñÔ∏è';
            
            document.getElementById('total-gainers').textContent = gainers;
            document.getElementById('total-losers').textContent = losers;
            document.getElementById('market-sentiment').textContent = sentiment;
        }
        
        function setSort(type) {
            currentSort = type;
            document.querySelectorAll('.filter-btn').forEach(btn => btn.classList.remove('active'));
            document.getElementById('btn-' + type).classList.add('active');
            if (type === 'change') bubbleData.sort((a, b) => Math.abs(b.change24h) - Math.abs(a.change24h));
            else if (type === 'volume') bubbleData.sort((a, b) => b.volume24h - a.volume24h);
            else if (type === 'alpha') bubbleData.sort((a, b) => a.symbol.localeCompare(b.symbol));
            renderBubbles();
        }
        
        function updateTime() { 
            document.getElementById('update-time').textContent = new Date().toLocaleTimeString('ro-RO', { 
                hour: '2-digit', minute: '2-digit', second: '2-digit' 
            }); 
        }
        
        function getColor(c) { 
            return c >= 0 
                ? d3.interpolateRgb('#00ff41', '#66ff7a')(Math.min(c / 25, 1))
                : d3.interpolateRgb('#ff0040', '#ff5c7c')(Math.min(Math.abs(c) / 25, 1));
        }
        
        // Render 80+ bubbles
        function renderBubbles() {
            const w = window.innerWidth;
            const isMobile = w < 768;
            d3.select('#bubble-container').selectAll('*').remove();
            
            if (bubbleData.length === 0) return;
            
            const gainers = bubbleData.filter(d => d.change24h >= 0).slice(0, BUBBLE_COUNT);
            const losers = bubbleData.filter(d => d.change24h < 0).slice(0, BUBBLE_COUNT);
            
            const baseRadius = isMobile ? 18 : 28;
            const cols = isMobile ? 3 : 5;
            const spacingX = (w / 2 - 40) / cols;
            const spacingY = isMobile ? 75 : 95;
            
            // Position gainers (left side)
            const gainersPos = gainers.map((d, i) => {
                const col = i % cols;
                const row = Math.floor(i / cols);
                const x = 30 + col * spacingX + spacingX / 2 + (Math.random() - 0.5) * 25;
                const y = 30 + row * spacingY + (Math.random() - 0.5) * 20;
                const r = baseRadius + Math.min(Math.abs(d.change24h) / 20, 1) * 12;
                return { ...d, x, y, r, side: 'left' };
            });
            
            // Position losers (right side)
            const losersPos = losers.map((d, i) => {
                const col = i % cols;
                const row = Math.floor(i / cols);
                const x = w / 2 + 30 + col * spacingX + spacingX / 2 + (Math.random() - 0.5) * 25;
                const y = 30 + row * spacingY + (Math.random() - 0.5) * 20;
                const r = baseRadius + Math.min(Math.abs(d.change24h) / 20, 1) * 12;
                return { ...d, x, y, r, side: 'right' };
            });
            
            const all = [...gainersPos, ...losersPos];
            const rows = Math.max(Math.ceil(gainers.length / cols), Math.ceil(losers.length / cols));
            const h = Math.max(window.innerHeight - 150, rows * spacingY + 100);
            
            const svg = d3.select('#bubble-container').append('svg').attr('width', w).attr('height', h);
            
            const bubbles = svg.selectAll('.bubble-group')
                .data(all)
                .enter()
                .append('g')
                .attr('class', 'bubble-group')
                .style('opacity', 0)
                .on('click', (e, d) => showModal(d));
            
            // Entry animation
            bubbles.transition()
                .duration(600)
                .delay((d, i) => i * 30)
                .ease(d3.easeBackOut)
                .style('opacity', 1);
            
            bubbles.each(function(d) {
                const g = d3.select(this);
                const col = getColor(d.change24h);
                const rad = d.r;
                
                // Outer glow ring
                g.append('circle')
                    .attr('r', rad + 12)
                    .attr('fill', d3.color(col).copy({opacity: 0.08}))
                    .attr('stroke', d3.color(col).copy({opacity: 0.15}))
                    .attr('stroke-width', 2);
                
                // Main spiral
                const sp = g.append('g').attr('class', 'bubble-spiral').style('color', col);
                
                // Draw 3 spiral rings
                [0.9, 0.7, 0.5].forEach((scale, idx) => {
                    let path = '';
                    const steps = 50;
                    const turns = 2.5 - idx * 0.3;
                    for (let i = 0; i <= steps; i++) {
                        const t = i / steps;
                        const angle = t * turns * 2 * Math.PI;
                        const radius = rad * (0.3 + 0.7 * t) * scale;
                        const x = radius * Math.cos(angle);
                        const y = radius * Math.sin(angle);
                        path += (i === 0 ? 'M' : 'L') + ` ${x.toFixed(1)} ${y.toFixed(1)}`;
                    }
                    sp.append('path')
                        .attr('d', path)
                        .attr('stroke', col)
                        .attr('stroke-width', idx === 0 ? 3.5 : idx === 1 ? 2.5 : 1.5)
                        .attr('fill', 'none')
                        .attr('opacity', idx === 0 ? 1 : idx === 1 ? 0.7 : 0.4)
                        .attr('stroke-linecap', 'round');
                });
                
                // Center glow
                sp.append('circle')
                    .attr('r', rad * 0.22)
                    .attr('fill', col)
                    .attr('filter', `drop-shadow(0 0 ${rad * 0.6}px ${col})`);
                
                // Symbol
                g.append('text')
                    .attr('class', 'bubble-label')
                    .attr('dy', '-0.15em')
                    .style('font-size', Math.min(rad / 1.5, isMobile ? 11 : 15) + 'px')
                    .text(d.symbol);
                
                // Change %
                g.append('text')
                    .attr('class', 'bubble-change')
                    .attr('dy', '1em')
                    .style('font-size', Math.min(rad / 2.2, isMobile ? 9 : 12) + 'px')
                    .text((d.change24h >= 0 ? '+' : '') + d.change24h.toFixed(1) + '%');
            });
            
            bubbles.attr('transform', d => `translate(${d.x}, ${d.y})`);
        }
        
        function updateBubbles() {
            d3.selectAll('.bubble-change').text(d => (d.change24h >= 0 ? '+' : '') + d.change24h.toFixed(1) + '%');
            d3.selectAll('.bubble-spiral').each(function(d) {
                const c = getColor(d.change24h);
                d3.select(this).style('color', c).selectAll('path').attr('stroke', c);
                d3.select(this).select('circle').attr('fill', c);
            });
        }
        
        function fmtNum(n) { 
            if (n >= 1e9) return (n / 1e9).toFixed(2) + 'B';
            if (n >= 1e6) return (n / 1e6).toFixed(2) + 'M';
            if (n >= 1e3) return (n / 1e3).toFixed(2) + 'K';
            return n.toFixed(2);
        }
        function fmtPrice(p) {
            if (p >= 10000) return p.toLocaleString('en-US', {maximumFractionDigits: 0});
            if (p >= 1000) return p.toLocaleString('en-US', {maximumFractionDigits: 1});
            if (p >= 1) return p.toFixed(2);
            return p.toFixed(4);
        }
        
        function generateChartData(price, change) {
            const data = []; let p = price / (1 + change / 100);
            for (let i = 0; i < 24; i++) { 
                p *= (1 + (Math.random() - 0.5) * Math.abs(change) / 100 * 0.4); 
                data.push(p); 
            }
            data[23] = price; return data;
        }
        
        function showModal(d) {
            currentModalCoin = d.symbol;
            document.getElementById('modal-symbol').textContent = d.symbol;
            const ce = document.getElementById('modal-change');
            ce.textContent = (d.change24h >= 0 ? '+' : '') + d.change24h.toFixed(2) + '%';
            ce.className = 'coin-change ' + (d.change24h >= 0 ? 'positive' : 'negative');
            document.getElementById('modal-price').textContent = '$' + fmtPrice(d.price);
            document.getElementById('modal-volume').textContent = '$' + fmtNum(d.volume24h);
            document.getElementById('modal-high').textContent = '$' + fmtPrice(d.high24h);
            document.getElementById('modal-low').textContent = '$' + fmtPrice(d.low24h);
            document.getElementById('modal').classList.add('active');
            
            setTimeout(() => {
                const ctx = document.getElementById('priceChart').getContext('2d');
                const isPos = d.change24h >= 0;
                const color = isPos ? '#00ff41' : '#ff0040';
                if (priceChart) priceChart.destroy();
                
                priceChart = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: Array(24).fill('').map((_, i) => i + 'h'),
                        datasets: [{
                            data: generateChartData(d.price, d.change24h),
                            borderColor: color,
                            backgroundColor: (ctx) => {
                                const g = ctx.chart.ctx.createLinearGradient(0, 0, 0, 200);
                                g.addColorStop(0, isPos ? 'rgba(0,255,65,0.4)' : 'rgba(255,0,64,0.4)');
                                g.addColorStop(1, 'rgba(0,0,0,0)');
                                return g;
                            },
                            borderWidth: 3,
                            fill: true,
                            tension: 0.4,
                            pointRadius: 0,
                            pointHoverRadius: 6
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: { legend: { display: false }, tooltip: {
                            backgroundColor: 'rgba(10,10,15,0.95)',
                            titleColor: '#fff',
                            bodyColor: '#fff',
                            borderColor: color,
                            borderWidth: 1,
                            padding: 10,
                            callbacks: { label: (ctx) => '$' + ctx.parsed.y.toFixed(4) }
                        }},
                        scales: {
                            x: { display: false },
                            y: { display: true, grid: { color: 'rgba(255,255,255,0.05)' }, ticks: { 
                                color: 'rgba(255,255,255,0.5)', font: { size: 10 }, callback: v => '$' + v.toFixed(2) 
                            }}
                        }
                    }
                });
            }, 50);
        }
        
        function updateModalData(coin) {
            if (!document.getElementById('modal').classList.contains('active')) return;
            document.getElementById('modal-price').textContent = '$' + fmtPrice(coin.price);
            document.getElementById('modal-high').textContent = '$' + fmtPrice(coin.high24h);
            document.getElementById('modal-low').textContent = '$' + fmtPrice(coin.low24h);
            document.getElementById('modal-volume').textContent = '$' + fmtNum(coin.volume24h);
            const ce = document.getElementById('modal-change');
            ce.textContent = (coin.change24h >= 0 ? '+' : '') + coin.change24h.toFixed(2) + '%';
            ce.className = 'coin-change ' + (coin.change24h >= 0 ? 'positive' : 'negative');
        }
        
        function closeModal(e) { 
            if (e.target === document.getElementById('modal')) { 
                document.getElementById('modal').classList.remove('active'); 
                currentModalCoin = null; 
            } 
        }
        
        document.addEventListener('keydown', (e) => { 
            if (e.key === 'Escape') { 
                document.getElementById('modal').classList.remove('active'); 
                currentModalCoin = null; 
            } 
        });
        
        let touchStartY = 0;
        document.getElementById('modal').addEventListener('touchstart', (e) => { touchStartY = e.touches[0].clientY; });
        document.getElementById('modal').addEventListener('touchend', (e) => { 
            if (e.changedTouches[0].clientY - touchStartY > 120) { 
                document.getElementById('modal').classList.remove('active'); 
                currentModalCoin = null; 
            } 
        });
        
        // Init
        loadData();
        setInterval(loadData, 30000);
    </script>
</body>
</html>